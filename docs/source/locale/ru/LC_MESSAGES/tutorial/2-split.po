# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Yaroslav Nikitenko
# This file is distributed under the same license as the Lena package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Lena 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-03 16:54+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/tutorial/2-split.rst:2 ../../source/tutorial/2-split.rst:541
msgid "Split"
msgstr ""

#: ../../source/tutorial/2-split.rst:4
msgid ""
"In this part of the tutorial we'll learn how to make several analyses "
"reading input data only once and without storing that in memory."
msgstr ""

#: ../../source/tutorial/2-split.rst:8
msgid "Contents"
msgstr ""

#: ../../source/tutorial/2-split.rst:11
msgid "Introduction"
msgstr ""

#: ../../source/tutorial/2-split.rst:13
msgid ""
"If we want to process same data flow \"simultaneously\" by *sequence1* "
"and *sequence2*, we use the element *Split*:"
msgstr ""

#: ../../source/tutorial/2-split.rst:16
msgid ""
"from lena.core import Split\n"
"\n"
"s = Sequence(\n"
"    ReadData(),\n"
"    Split([\n"
"        sequence1,\n"
"        sequence2,\n"
"        # ...\n"
"    ]),\n"
"    ToCSV(),\n"
"    # ...\n"
")"
msgstr ""

#: ../../source/tutorial/2-split.rst:31
msgid ""
"The first argument of *Split* is a list of sequences, which are applied "
"to the incoming flow \"in parallel\" (not in the sense of processes or "
"threads)."
msgstr ""

#: ../../source/tutorial/2-split.rst:35
msgid ""
"However, not every sequence can be used in parallel with others. Recall "
"the example of an element *Sum* from the first part of the tutorial:"
msgstr ""

#: ../../source/tutorial/2-split.rst:38
msgid ""
"class Sum1():\n"
"    def run(self, flow):\n"
"        s = 0\n"
"        for val in flow:\n"
"            s += val\n"
"        yield s"
msgstr ""

#: ../../source/tutorial/2-split.rst:47
msgid ""
"The problem is that if we pass it a *flow*, it will consume it "
"completely. After we call *Sum1().run(flow)*, there is no way to stop "
"iteration in the inner cycle and resume that later. To reiterate the "
"*flow* in another sequence we would have to store that in memory or "
"reread all data once again."
msgstr ""

#: ../../source/tutorial/2-split.rst:53
msgid ""
"To run analyses in parallel, we need another type of element. Here is "
"*Sum* refactored:"
msgstr ""

#: ../../source/tutorial/2-split.rst:58
msgid ""
"class Sum():\n"
"    def __init__(self):\n"
"        self._sum = 0\n"
"\n"
"    def fill(self, val):\n"
"        self._sum += val\n"
"\n"
"    def compute(self):\n"
"        yield self._sum"
msgstr ""

#: ../../source/tutorial/2-split.rst:73
msgid ""
"This *Sum* has methods *fill(value)* and *compute()*. *Fill* is called by"
" some external code (for example, by *Split*). After there is nothing "
"more to fill, the results can be generated by *compute*. The method name "
"*fill* makes its class similar to a histogram. *Compute* in this example "
"is trivial, but it may include some larger computations. We call an "
"element with methods *fill* and *compute* a *FillCompute* element. An "
"element with a *run* method can be called a *Run* element."
msgstr ""

#: ../../source/tutorial/2-split.rst:82
msgid ""
"A *FillCompute* element can be generalized. We can place before that "
"simple functions, which will transform values before they fill the "
"element. We can also add other elements after *FillCompute*. Since "
"*compute* is a generator, these elements can be either simple functions "
"or *Run* elements. A sequence with a *FillCompute* element is called a "
"*FillComputeSeq*."
msgstr ""

#: ../../source/tutorial/2-split.rst:90
msgid "Here is a working example:"
msgstr ""

#: ../../source/tutorial/2-split.rst:92
msgid "tutorial/2_split/main1.py"
msgstr ""

#: ../../source/tutorial/2-split.rst:92
msgid ""
"data_file = os.path.join(\"..\", \"data\", \"normal_3d.csv\")\n"
"s = Sequence(\n"
"    ReadData(),\n"
"    Split([\n"
"        (\n"
"            lambda vec: vec[0],\n"
"            Histogram(mesh((-10, 10), 10)),\n"
"            ToCSV(),\n"
"            Writer(\"output\", \"x\"),\n"
"        ),\n"
"        (\n"
"            lambda vec: vec[1],\n"
"            Histogram(mesh((-10, 10), 10)),\n"
"            ToCSV(),\n"
"            Writer(\"output\", \"y\"),\n"
"        ),\n"
"    ]),\n"
"    RenderLaTeX(\"histogram_1d.tex\", \"templates\"),\n"
"    Writer(\"output\"),\n"
"    LaTeXToPDF(),\n"
"    PDFToPNG(),\n"
")\n"
"results = s.run([data_file])\n"
"for res in results:\n"
"    print(res)"
msgstr ""

#: ../../source/tutorial/2-split.rst:121
msgid ""
"Lena Histogram is a FillCompute element. The elements of the list in "
"*Split* (tuples in this example) during the initialization of *Split* are"
" transformed into FillCompute sequences. The *lambdas* select parts of "
"vectors, which will fill the corresponding histogram. After the histogram"
" is filled, it is given appropriate name by *Writer* (so that they could "
"be distinguished in the following flow)."
msgstr ""

#: ../../source/tutorial/2-split.rst:131
msgid ""
"*Writer* has two initialization parameters: the default directory and the"
" default file name. Writer only writes strings (and *unicode* in Python "
"2). Its corresponding context is called *output* (as its module). If "
"*output* is missing in the context, values pass unchanged. Otherwise, "
"file name and extension are searched in *context.output*. If "
"*output.filename* or *output.fileext* are missing, then the default file "
"name or \"txt\" are used. The default file name should be used only when "
"you are sure that only one file is going to be written, otherwise it will"
" be rewritten every time. The defaults *Writer*'s parameters are empty "
"string (current directory) and \"output\" (resulting in *output.txt*)."
msgstr ""

#: ../../source/tutorial/2-split.rst:144
msgid ""
"*ToCSV* yields a string and sets *context.output.fileext* to *\"csv\"*. "
"In the example above Writer objects write CSV data to *output/x.csv* and "
"*output/y.csv*."
msgstr ""

#: ../../source/tutorial/2-split.rst:148
msgid ""
"For each file written, *Writer* yields a tuple *(file path, context)*, "
"where *context.output.filepath* is updated with the path to file."
msgstr ""

#: ../../source/tutorial/2-split.rst:151
msgid ""
"After the histograms are filled and written, *Split* yields them into the"
" following flow in turn. The containing sequence *s* doesn't distinguish "
"*Split* from other elements, because *Split* acts as any *Run* element."
msgstr ""

#: ../../source/tutorial/2-split.rst:157
msgid "Variables"
msgstr ""

#: ../../source/tutorial/2-split.rst:158
msgid ""
"One of the basic principles in programming is \"don't repeat yourself\" "
"(*DRY*)."
msgstr ""

#: ../../source/tutorial/2-split.rst:161
msgid ""
"In the example above, we wanted to give distinct names to histograms in "
"different analysis branches, and used two *writers* to do that. However, "
"we can move *ToCSV* and *Writer* outside the *Split* (and make our code "
"one line shorter):"
msgstr ""

#: ../../source/tutorial/2-split.rst:169
msgid "tutorial/2_split/main2.py"
msgstr ""

#: ../../source/tutorial/2-split.rst:169
msgid ""
"from lena.output import MakeFilename\n"
"s = Sequence(\n"
"    ReadData(),\n"
"    Split([\n"
"        (\n"
"            lambda vec: vec[0],\n"
"            Histogram(mesh((-10, 10), 10)),\n"
"            MakeFilename(\"x\"),\n"
"        ),\n"
"        (\n"
"            lambda vec: vec[1],\n"
"            Histogram(mesh((-10, 10), 10)),\n"
"            MakeFilename(\"y\"),\n"
"        ),\n"
"    ]),\n"
"    ToCSV(),\n"
"    Writer(\"output\"),\n"
"    # ... as earlier ...\n"
")"
msgstr ""

#: ../../source/tutorial/2-split.rst:192
msgid ""
"Element *MakeFilename* adds file name to *context.output*. *Writer* "
"doesn't need a default file name anymore. Now it writes two different "
"files, because *context.output.filename* is different."
msgstr ""

#: ../../source/tutorial/2-split.rst:197
msgid ""
"The code that we've written now is very explicit and flexible. We clearly"
" see each step of the analysis and it as a whole. We control output names"
" and we can change the logic as we wish by adding another element or "
"*lambda*. The structure of our analysis is very transparent, but the code"
" is not beautiful enough."
msgstr ""

#: ../../source/tutorial/2-split.rst:203
msgid ""
"Lambdas don't improve readability. Indices *0* and *1* look like magic "
"constants. They are connected to names *x* and *y* in the following flow,"
" but let us unite them in one element (and improve the *cohesion* of our "
"code):"
msgstr ""

#: ../../source/tutorial/2-split.rst:208
msgid "tutorial/2_split/main3.py"
msgstr ""

#: ../../source/tutorial/2-split.rst:208
msgid ""
"from lena.variables import Variable\n"
"\n"
"def main():\n"
"    data_file = os.path.join(\"..\", \"data\", \"normal_3d.csv\")\n"
"    writer = Writer(\"output\")\n"
"    s = Sequence(\n"
"        ReadData(),\n"
"        Split([\n"
"            (\n"
"                Variable(\"x\", lambda vec: vec[0]),\n"
"                Histogram(mesh((-10, 10), 10)),\n"
"            ),\n"
"            (\n"
"                Variable(\"y\", lambda vec: vec[1]),\n"
"                Histogram(mesh((-10, 10), 10)),\n"
"            ),\n"
"            (\n"
"                Variable(\"z\", lambda vec: vec[2]),\n"
"                Histogram(mesh((-10, 10), 10)),\n"
"            ),\n"
"        ]),\n"
"        MakeFilename(\"{{variable.name}}\"),\n"
"        ToCSV(),\n"
"        writer,\n"
"        RenderLaTeX(\"histogram_1d.tex\", \"templates\"),\n"
"        writer,\n"
"        LaTeXToPDF(),\n"
"        PDFToPNG(),\n"
"    )\n"
"    results = s.run([data_file])\n"
"    for res in results:\n"
"        print(res)"
msgstr ""

#: ../../source/tutorial/2-split.rst:244
msgid ""
"A *Variable* is essentially a function with a name. It transforms data "
"and adds its own name to *context.variable.name*."
msgstr ""

#: ../../source/tutorial/2-split.rst:247
msgid ""
"In this example we initialize a variable with a name and a function. It "
"can accept arbitrary keyword arguments, which will be added to its "
"context. For example, if our data is a series of *(positron, neutron)* "
"events, then we can make a variable to select the second event:"
msgstr ""

#: ../../source/tutorial/2-split.rst:252
msgid ""
"neutron = Variable(\n"
"   \"neutron\", lambda double_ev: double_ev[1],\n"
"   latex_name=\"n\", type=\"particle\"\n"
")"
msgstr ""

#: ../../source/tutorial/2-split.rst:259
msgid ""
"In this case *context.variable* will be updated not only with *name*, but"
" also *latex_name* and *type*. In code their values can be got as "
"variable's attributes (e.g. *neutron.latex_name*). Variable's function "
"can be initialized with the keyword *getter* and is available as a method"
" *getter*."
msgstr ""

#: ../../source/tutorial/2-split.rst:266
msgid ""
"*MakeFilename* accepts not only constant, but also format strings, which "
"take arguments from context. In our example, "
"*MakeFilename(\"{{variable.name}}\")* creates file name from "
"*context.variable.name*."
msgstr ""

#: ../../source/tutorial/2-split.rst:270
msgid ""
"Note also that since two *Writers* do the same thing, we rewrote them as "
"one object."
msgstr ""

#: ../../source/tutorial/2-split.rst:273
msgid "Combine"
msgstr ""

#: ../../source/tutorial/2-split.rst:274
msgid "Variables can be joined into a multidimensional variable using *Combine*."
msgstr ""

#: ../../source/tutorial/2-split.rst:276
msgid ""
"*Combine(var1, var2, ...)* applied to a *value* is a tuple "
"*((var1.getter(value), var2.getter(value), ...), context)*. The first "
"element of the tuple is *value* transformed by each of the composed "
"variables. *Variable.getter* is a function that returns only data without"
" context."
msgstr ""

#: ../../source/tutorial/2-split.rst:280
msgid ""
"*Combine* is a subclass of a *Variable*, and it accepts arbitrary "
"keywords during initialization. All positional arguments must be "
"*Variables*. Name of the combined variable can be passed as a keyword "
"argument. If not provided, it is its variables' names joined with '_'."
msgstr ""

#: ../../source/tutorial/2-split.rst:285
msgid ""
"The resulting context is that of a usual *Variable* updated with "
"*context.variable.combine*, where *combine* is a tuple of each variable's"
" context."
msgstr ""

#: ../../source/tutorial/2-split.rst:289
msgid ""
"*Combine* has an attribute *dim*, which is the number of its variables. A"
" constituting variable can be accessed using its index. For example, if "
"*cv* is *Combine(var1, var2)*, then *cv.dim* is 2, *cv.name* is "
"*var1.name_var2.name*, and *cv[1]* is *var2*."
msgstr ""

#: ../../source/tutorial/2-split.rst:294
msgid "*Combine* variables are used for multidimensional plots."
msgstr ""

#: ../../source/tutorial/2-split.rst:297
msgid "Compose"
msgstr ""

#: ../../source/tutorial/2-split.rst:298
msgid ""
"When we put several variables or functions into a sequence, we obtain "
"their composition. In the Lena framework we want to preserve as much "
"context as possible. If some previous element was a *Variable*, its "
"context is moved into *variable.compose* subcontext."
msgstr ""

#: ../../source/tutorial/2-split.rst:304
msgid "Function composition can be also defined as *variables.Compose*."
msgstr ""

#: ../../source/tutorial/2-split.rst:306
msgid ""
"In this example we first select the *neutron* part of the data, and then "
"the *x* coordinate:"
msgstr ""

#: ../../source/tutorial/2-split.rst:309
msgid ""
">>> from lena.variables import Variable, Compose\n"
">>> # data is pairs of (positron, neutron) coordinates\n"
">>> data = [((1.05, 0.98, 0.8), (1.1, 1.1, 1.3))]\n"
">>> x = Variable(\n"
"...    \"x\", lambda coord: coord[0], type=\"coordinate\"\n"
"... )\n"
">>> neutron = Variable(\n"
"...    \"neutron\", latex_name=\"n\",\n"
"...    getter=lambda double_ev: double_ev[1], type=\"particle\"\n"
"... )\n"
">>> x_n = Compose(neutron, x)\n"
">>> x_n(data[0])[0] # data\n"
"1.1"
msgstr ""

#: ../../source/tutorial/2-split.rst:325
msgid ""
"Data part of the result, as expected, is the composition of variables "
"*neutron* and *x*. Same result could be obtained as a sequence of "
"variables: *Sequence(neutron, x).run(data)*, but the context of *Compose*"
" is created differently."
msgstr ""

#: ../../source/tutorial/2-split.rst:329
msgid ""
"The name of the composed variable is names of its variables (from left to"
" right) joined with underscore. If there are two variables, LaTeX name "
"will be also created from their names (or LaTeX names, if present) as a "
"subscript in reverse order. In our example the context will be this:"
msgstr ""

#: ../../source/tutorial/2-split.rst:335
msgid ""
">>> x_n(data[0])[1]\n"
"{\n"
"    'variable': {\n"
"        'name': 'neutron_x', 'particle': 'neutron',\n"
"        'latex_name': 'x_{n}', 'coordinate': 'x', 'type': 'coordinate',\n"
"        'compose': {\n"
"            'type': 'particle', 'latex_name': 'n',\n"
"            'name': 'neutron', 'particle': 'neutron'\n"
"        },\n"
"    }\n"
"}"
msgstr ""

#: ../../source/tutorial/2-split.rst:349
msgid ""
"Context of the composed variable is updated with a *compose* subcontext, "
"which makes it similar to the context produced by variables in a "
"sequence."
msgstr ""

#: ../../source/tutorial/2-split.rst:352
msgid ""
"As for any variable, *name* or other parameters can be passed as keyword "
"arguments during initialization."
msgstr ""

#: ../../source/tutorial/2-split.rst:355
msgid ""
"Keyword *type* has a special meaning. If present, then during "
"initialization of a variable its context is updated with *{variable.type:"
" variable.name}* pair. During variable composition (in *Compose* or by "
"subsequent application to the *flow*) *context.variable* is updated with "
"new variable's context, but if its type is different, it will persist. "
"This allows access to *context.variable.particle* even if it was later "
"composed with other variables."
msgstr ""

#: ../../source/tutorial/2-split.rst:366
msgid "Analysis example"
msgstr ""

#: ../../source/tutorial/2-split.rst:368
msgid ""
"Let us combine what we've learnt before and use it in a real analysis. An"
" important change would be that if we create 2-dimensional plots, we add "
"another template for that. Below is a small example. All template "
"commands were explained in the first part of the tutorial."
msgstr ""

#: ../../source/tutorial/2-split.rst:374
msgid "tutorial/2_split/templates/histogram_2d.tex"
msgstr ""

#: ../../source/tutorial/2-split.rst:374
msgid ""
"\\documentclass{standalone}\n"
"\\usepackage{tikz}\n"
"\\usepackage{pgfplots}\n"
"\\usepgfplotslibrary{colorbrewer}\n"
"\\pgfplotsset{compat=1.15}\n"
"\n"
"\\BLOCK{ set varx = variable.combine[0] }\n"
"\\BLOCK{ set vary = variable.combine[1] }\n"
"\n"
"\\begin{document}\n"
"\\begin{tikzpicture}\n"
"    \\begin{axis}[\n"
"        view={0}{90},\n"
"        grid=both, \n"
"        \\BLOCK{ set xcols = histogram.nbins[0]|int + 1 }\n"
"        \\BLOCK{ set ycols = histogram.nbins[1]|int + 1 }\n"
"        mesh/cols=\\VAR{xcols},\n"
"        mesh/rows=\\VAR{ycols},\n"
"        colorbar horizontal,\n"
"        xlabel = {$\\VAR{ varx.latex_name }$\n"
"            \\BLOCK{ if varx.unit }[$\\mathrm{\\VAR{ varx.unit "
"}}$]\\BLOCK{ endif }},\n"
"        ylabel = {$\\VAR{ vary.latex_name }$\n"
"            \\BLOCK{ if vary.unit }[$\\mathrm{\\VAR{ vary.unit "
"}}$]\\BLOCK{ endif }},\n"
"    ]\n"
"    \\addplot3 [\n"
"        surf,\n"
"        mesh/ordering=y varies,\n"
"    ] table [col sep=comma, header=false] {\\VAR{ output.filepath }};\n"
"    \\end{axis}\n"
"\\end{tikzpicture}\n"
"\\end{document}\n"
msgstr ""

#: ../../source/tutorial/2-split.rst:378
msgid "If an axis has a *unit*, it will be added to its label (like *x [cm]*)."
msgstr ""

#: ../../source/tutorial/2-split.rst:380
msgid ""
"*RenderLaTeX* accepts a function as the first initialization argument or "
"as a keyword *select_template*. That function must accept a value "
"(presumably a *(data, context)* pair) from the flow, and return a "
"template file name (to be found inside *template_path*)."
msgstr ""

#: ../../source/tutorial/2-split.rst:387
msgid "tutorial/2_split/main4.py"
msgstr ""

#: ../../source/tutorial/2-split.rst:387
msgid ""
"from __future__ import print_function\n"
"\n"
"import os\n"
"\n"
"import lena.context\n"
"import lena.flow\n"
"from lena.core import Sequence, Split, Source\n"
"from lena.structures import Histogram\n"
"from lena.math import mesh\n"
"from lena.output import ToCSV, Writer, LaTeXToPDF, PDFToPNG\n"
"from lena.output import MakeFilename, RenderLaTeX\n"
"from lena.variables import Variable, Compose, Combine\n"
"\n"
"from read_data import ReadDoubleEvents\n"
"\n"
"\n"
"positron = Variable(\n"
"    \"positron\", latex_name=\"e^+\",\n"
"    getter=lambda double_ev: double_ev[0], type=\"particle\"\n"
")\n"
"neutron = Variable(\n"
"    \"neutron\", latex_name=\"n\",\n"
"    getter=lambda double_ev: double_ev[1], type=\"particle\"\n"
")\n"
"x = Variable(\"x\", lambda vec: vec[0], latex_name=\"x\", unit=\"cm\", "
"type=\"coordinate\")\n"
"y = Variable(\"y\", lambda vec: vec[1], latex_name=\"y\", unit=\"cm\", "
"type=\"coordinate\")\n"
"z = Variable(\"z\", lambda vec: vec[2], latex_name=\"z\", unit=\"cm\", "
"type=\"coordinate\")\n"
"\n"
"coordinates_1d = [\n"
"    (\n"
"        coordinate,\n"
"        Histogram(mesh((-10, 10), 10)),\n"
"    )\n"
"    for coordinate in [\n"
"        Compose(particle, coord)\n"
"            for coord in x, y, z\n"
"            for particle in positron, neutron\n"
"    ]\n"
"]\n"
"\n"
"\n"
"def select_template(val):\n"
"    data, context = lena.flow.get_data_context(val)\n"
"    if lena.context.get_recursively(context, \"histogram.dim\", None) == "
"2:\n"
"        return \"histogram_2d.tex\"\n"
"    else:\n"
"        return \"histogram_1d.tex\"\n"
"\n"
"\n"
"def main():\n"
"    data_file = os.path.join(\"..\", \"data\", \"double_ev.csv\")\n"
"    writer = Writer(\"output\")\n"
"    s = Sequence(\n"
"        ReadDoubleEvents(),\n"
"        Split(\n"
"            coordinates_1d\n"
"            + \n"
"            [(\n"
"                particle,\n"
"                Combine(x, y, name=\"xy\"),\n"
"                Histogram(mesh(((-10, 10), (-10, 10)), (10, 10))),\n"
"                "
"MakeFilename(\"{{variable.particle}}/{{variable.name}}\"),\n"
"             )\n"
"             for particle in positron, neutron\n"
"            ]\n"
"        ),\n"
"        MakeFilename(\"{{variable.particle}}/{{variable.coordinate}}\"),\n"
"        ToCSV(),\n"
"        writer,\n"
"        RenderLaTeX(select_template, template_path=\"templates\"),\n"
"        writer,\n"
"        LaTeXToPDF(),\n"
"        PDFToPNG(),\n"
"    )\n"
"    results = s.run([data_file])\n"
"    for res in results:\n"
"        print(res)\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
msgstr ""

#: ../../source/tutorial/2-split.rst:390
msgid ""
"We import *ReadDoubleEvents* from a separate file. That class is "
"practically the same as earlier, but it yields pairs of events instead of"
" one by one."
msgstr ""

#: ../../source/tutorial/2-split.rst:394
msgid ""
"We define *coordinates_1d* as a simple list of coordinates' composition. "
"Note that we could make all combinations directly using the language. We "
"could also do that in *Split*, but if we use all these coordinates "
"together in different analyses or don't want to clutter the algorithm "
"code, we can separate them."
msgstr ""

#: ../../source/tutorial/2-split.rst:400
msgid ""
"In our new function *select_template* we use "
"*lena.context.get_recursively*. This function is needed because we often "
"have nested dictionaries, and Python's *dict.get* method doesn't recurse."
" We provide the default return value ``None``, so that it doesn't raise "
"an exception in case of a missing key."
msgstr ""

#: ../../source/tutorial/2-split.rst:412
msgid ""
"In the *Split* element we fill histograms for 1- and 2-dimensional plots "
"in one run. There are two *MakeFilename* elements, but *MakeFilename* "
"doesn't overwrite file names set previously."
msgstr ""

#: ../../source/tutorial/2-split.rst:416
msgid ""
"We created our first 2-dimensional histogram using *lena.math.mesh*. It "
"accepts parameters *ranges* and *nbins*. In a multidimensional case these"
" parameters are tuples of ranges and number of bins in corresponding "
"dimensions, as in *mesh(((-10, 10), (-10, 10)), (10, 10))*."
msgstr ""

#: ../../source/tutorial/2-split.rst:422
msgid ""
"After we run this script, we obtain two subdirectories in *output* for "
"*positron* and *neutron*, each containing 4 plots (both *pdf* and *png*);"
" in total 8 plots with proper names, units, axes labels, etc. It is "
"straightforward to add other plots if we want, or to disable some of them"
" in *Split* by commenting them out. The variables that we defined at the "
"top level could be reused in other modules or moved to a separate module."
msgstr ""

#: ../../source/tutorial/2-split.rst:431
msgid ""
"Note the overall design of our algorithm. We prepare all necessary data "
"in *ReadDoubleEvents*. After that, *Split* uses different parts of these "
"double events to create different plots. All important parameters should "
"be contained in data itself. These allows a separation of data from "
"presentation."
msgstr ""

#: ../../source/tutorial/2-split.rst:438
msgid ""
"The knowledge we'll learn by the end of this chapter will be sufficient "
"for most of practical analyses. Following sections give more details "
"about Lena elements and usage."
msgstr ""

#: ../../source/tutorial/2-split.rst:444
msgid "Adapters, elements and sequences"
msgstr ""

#: ../../source/tutorial/2-split.rst:446
msgid ""
"Objects don't need to inherit from *Lena* classes to be used in the "
"framework. Instead, they have to implement methods with specified names "
"(like *run*, *fill*, etc). This is called structural subtyping in Python "
"[#f1]_."
msgstr ""

#: ../../source/tutorial/2-split.rst:450
msgid ""
"The specified method names can be changed using *adapters*. For example, "
"if we have a legacy class"
msgstr ""

#: ../../source/tutorial/2-split.rst:453
msgid ""
"class MyEl():\n"
"    def my_run(self, flow):\n"
"        for val in flow:\n"
"            yield val"
msgstr ""

#: ../../source/tutorial/2-split.rst:460
msgid ""
"then we can create a *Run* element from a *MyEl* object with the adapter "
"*Run*:"
msgstr ""

#: ../../source/tutorial/2-split.rst:462
msgid ""
">>> from lena.core import Run\n"
">>> my_run = Run(MyEl(), run=\"my_run\")\n"
">>> list(my_run.run([1, 2, 3]))\n"
"[1, 2, 3]"
msgstr ""

#: ../../source/tutorial/2-split.rst:469
msgid ""
"The adapter receives method name as a keyword argument. After it is "
"created, it can be called with a method named *run* or inserted into a "
"*Lena* sequence."
msgstr ""

#: ../../source/tutorial/2-split.rst:473
msgid ""
"Similarly, a *FillCompute* adapter accepts names for methods *fill* and "
"*compute*:"
msgstr ""

#: ../../source/tutorial/2-split.rst:476
msgid "FillCompute(el, fill='fill', compute='compute')"
msgstr ""

#: ../../source/tutorial/2-split.rst:480
msgid ""
"If callable methods *fill* and *compute* were not found in *el*, "
"*LenaTypeError* is raised."
msgstr ""

#: ../../source/tutorial/2-split.rst:482
msgid ""
"What other types of elements are possible in data analysis? A common "
"algorithm in physics is event selection. We analyse a large set of data "
"looking for specific events. These events can be missing there or "
"contained in a large quantity. To deal with this, we have to be prepared "
"not to consume all flow (as a *Run* element does) and not to store all "
"flow in the element before that is yielded. We create an element with a "
"*fill* method, and call the second method *request*. A *FillRequest* "
"element is similar to *FillCompute*, but *request* can be called multiple"
" times. As with *FillComputeSeq*, we can add *Call* elements (lambdas) "
"before a *FillRequest* element and *Call* or *Run* elements after that to"
" create a sequence *FillRequestSeq*."
msgstr ""

#: ../../source/tutorial/2-split.rst:497
msgid ""
"Elements can be transformed one into another. During initialization a "
"*Sequence* checks for each its argument whether it has a *run* method. If"
" it is missing, it tries to convert the element to a *Run* element using "
"the adapter."
msgstr ""

#: ../../source/tutorial/2-split.rst:503
msgid ""
"*Run* can be initialized from a *Call* or a *FillCompute* element. A "
"callable is run as a transformation function, which accepts single values"
" from the flow and returns their transformations for each value:"
msgstr ""

#: ../../source/tutorial/2-split.rst:508
msgid ""
"for val in flow:\n"
"    yield self._el(val)"
msgstr ""

#: ../../source/tutorial/2-split.rst:513
msgid ""
"A *FillCompute* element is run the following way: first, *fill(value)* is"
" called for the whole flow. After the flow is exhausted, *compute()* is "
"called."
msgstr ""

#: ../../source/tutorial/2-split.rst:517
msgid ""
"There are algorithms and structures which are inherently not memory safe."
" For example, *lena.structures.Graph* stores all filled data as its "
"points, and it is a *FillRequest* element. Since *FillRequest* can't be "
"used directly in a *Sequence*, or if we want to yield only the final "
"result once, we cast that with *FillCompute(Graph())*. We can do that "
"when we are sure that our data won't overflow memory, and that cast will "
"be explicit in our code."
msgstr ""

#: ../../source/tutorial/2-split.rst:527
msgid "To sum up, adapters in Lena can be used for several purposes:"
msgstr ""

#: ../../source/tutorial/2-split.rst:529
msgid "provide a different name for a method (*Run(my_obj, run=\"my_run\")*),"
msgstr ""

#: ../../source/tutorial/2-split.rst:530
msgid ""
"hide unused methods to prevent ambiguity (if an element has many methods,"
" we can wrap that in an adapter to expose only the needed ones),"
msgstr ""

#: ../../source/tutorial/2-split.rst:531
msgid ""
"automatically convert objects of one type to another in sequences "
"(*FillCompute* to *Run*),"
msgstr ""

#: ../../source/tutorial/2-split.rst:532
msgid ""
"explicitly cast object of one type to another (*FillRequest* to "
"*FillCompute*)."
msgstr ""

#: ../../source/tutorial/2-split.rst:543
msgid ""
"In the examples above, *Split* contained several *FillComputeSeq* "
"sequences. However, it can be used with all other sequences we know."
msgstr ""

#: ../../source/tutorial/2-split.rst:547
msgid ""
"*Split* has a keyword initialization argument *bufsize*, which is the "
"size of the buffer for the input flow."
msgstr ""

#: ../../source/tutorial/2-split.rst:550
msgid ""
"During *Split.run(flow)*, the *flow* is divided into subslices of "
"*bufsize*. Each subslice is processed by sequences in the order of their "
"initializer list (the first positional argument in *Split.__init__*)."
msgstr ""

#: ../../source/tutorial/2-split.rst:555
msgid ""
"If a sequence is a *Source*, it doesn't accept the incoming *flow*, but "
"produces its own complete flow and becomes inactive (is not called any "
"more)."
msgstr ""

#: ../../source/tutorial/2-split.rst:560
msgid ""
"A *FillRequestSeq* is filled with the buffer contents. After the buffer "
"is finished, it yields all values from *request()*."
msgstr ""

#: ../../source/tutorial/2-split.rst:564
msgid ""
"A *FillComputeSeq* is filled with values from each buffer, but yields "
"values from *compute* only after the whole *flow* is finished."
msgstr ""

#: ../../source/tutorial/2-split.rst:568
msgid ""
"A *Sequence* is called with *run(buffer)* instead of the whole flow. The "
"results are yielded for each buffer. If the whole flow must be analysed "
"at once, don't use such a sequence in *Split*."
msgstr ""

#: ../../source/tutorial/2-split.rst:574
msgid ""
"If the *flow* was empty, each *__call__* (from *Source*), *compute*, "
"*request* or *run* is called nevertheless."
msgstr ""

#: ../../source/tutorial/2-split.rst:578
msgid ""
"*Source* within *Split* can be used to add new data to *flow*. For "
"example, we can create *Split([source, ()])*, and in this place of a "
"sequence first all data from *source* will be generated, then all data "
"from preceding elements will be passed (empty *Sequence* passes values "
"unchanged). This can be used to provide several flows to a further "
"element (like data, Monte Carlo and analytical approximation)."
msgstr ""

#: ../../source/tutorial/2-split.rst:586
msgid ""
"*Split* acts both as a sequence (because it contains sequences) and as an"
" element. If all its elements (sequences, to be precise) have the same "
"type, *Split* will have methods of this type. For example, if *Split* has"
" only *FillComputeSeq* inside, it will create methods *fill* and "
"*compute*. During *fill* all its sequences will be filled. During "
"*compute* their results will be yielded in turn (all results from the "
"first sequence, then from the second, etc). *Split* with *Source* "
"sequences will act as a *Source*. Of course, *Split* can be used within a"
" *Split*."
msgstr ""

#: ../../source/tutorial/2-split.rst:599
msgid "Context. Performance and safety"
msgstr ""

#: ../../source/tutorial/2-split.rst:601
msgid ""
"Dictionaries in Python are *mutable*, that is their content can change. "
"If an element stores the current context, that may be changed by some "
"other element. The simplest example: if your original data has context, "
"it will be changed after being processed by a sequence."
msgstr ""

#: ../../source/tutorial/2-split.rst:606
msgid ""
"This is how a typical *Run* element deals with context. To be most "
"useful, it must be prepared to accept data with and without context:"
msgstr ""

#: ../../source/tutorial/2-split.rst:610
msgid ""
"class RunEl():\n"
"    def __init__(self):\n"
"        self._context = {\"subcontext\": \"el\"}\n"
"\n"
"    def run(self, flow):\n"
"        for val in flow:\n"
"            data, context = lena.flow.get_data_context(val)\n"
"            # ... do something ...\n"
"            lena.flow.update_recursively(context, self._context)\n"
"            yield (new_data, context)"
msgstr ""

#: ../../source/tutorial/2-split.rst:623
msgid ""
"*lena.flow.get_data_context(value)* splits *value* into a pair of (data, "
"context). If *value* contained only data without context, the *context* "
"part will be an empty dictionary (therefore it is safe to use "
"*get_data_context* with any *value*). If only one part is needed, "
"*lena.flow.get_data* or *lena.flow.get_context* can be used."
msgstr ""

#: ../../source/tutorial/2-split.rst:629
msgid ""
"If *subcontext* can contain other elements except *el*, then to preserve "
"them we call not *context.update*, but *lena.flow.update_recursively*. "
"This function doesn't overwrite subdictionaries, but only conflicting "
"keys within them. In this case *context.subcontext* key will always be "
"set to *el*, but if *self._context.subcontext* were a dictionary "
"*{\"el\": \"el1\"}*, then all *context.subcontext* keys (if present) "
"except *el* would remain."
msgstr ""

#: ../../source/tutorial/2-split.rst:638
msgid ""
"Usually elements in a *Sequence* yield computed data and context, and "
"never use or change that again. In *Split*, however, several sequences "
"use the same data simultaneously. This is why *Split* makes a deep copy "
"of the incoming flow in its buffer. A deep copy of a context is "
"completely independent of the original or its other copies. However, to "
"copy an entire dictionary requires some computational cost."
msgstr ""

#: ../../source/tutorial/2-split.rst:645
msgid ""
"*Split* can be initialized with a keyword argument *copy_buf*. By default"
" it is ``True``, but can be set to ``False`` to disable deep copy of the "
"flow. This may be a bit faster, but do it only if you are absolutely sure"
" that your analysis will remain correct."
msgstr ""

#: ../../source/tutorial/2-split.rst:652
msgid "There are several things in Lena that help against context interference:"
msgstr ""

#: ../../source/tutorial/2-split.rst:654
msgid ""
"elements change their own context (*Writer* changes *context.output* and "
"not *context.variable*),"
msgstr ""

#: ../../source/tutorial/2-split.rst:655
msgid ""
"if *Split* has several sequences, it makes a deep copy of the flow before"
" feeding that to them,"
msgstr ""

#: ../../source/tutorial/2-split.rst:656
msgid ""
"*FillCompute* and *FillRequest* elements make a deep copy of context "
"before yielding [#f3]_."
msgstr ""

#: ../../source/tutorial/2-split.rst:658
msgid "This is how a *FillCompute* element is usually organised in Lena:"
msgstr ""

#: ../../source/tutorial/2-split.rst:660
msgid ""
"class MyFillComputeEl():\n"
"    def __init__(self):\n"
"        self._val = 0\n"
"        self._context = {\"subcontext\": \"el\"}\n"
"        self._cur_context = {}\n"
"\n"
"    def fill(self, val):\n"
"        data, context = lena.flow.get_data_context(val)\n"
"        self._val += data\n"
"        self._cur_context = context\n"
"\n"
"    def compute(self):\n"
"        context = copy.deepcopy(self._cur_context)\n"
"        # or copy.deepcopy(self._context):\n"
"        lena.flow.update_recursively(context, self._context)\n"
"        yield (self._val, context)"
msgstr ""

#: ../../source/tutorial/2-split.rst:679
msgid ""
"During *fill* the last context is saved. During *compute* a deep copy of "
"that is made (since *compute* is called only once, this can be done "
"without performance loss), and it is updated with *self._context*."
msgstr ""

#: ../../source/tutorial/2-split.rst:690
msgid ""
"Performance is not the highest priority in Lena, but it is always nice to"
" have. When possible, optimizations are made. Performance measurements "
"show that *deepcopy* can take most time in Lena analysis [#f2]_. A linear"
" *Sequence* or *Run* elements don't do a deep copy of data. If *Split* "
"contains several sequences, it doesn't do a deep copy of the flow for the"
" last sequence. It is possible to circumvent all copying of data in "
"*Split* to gain more performance at the cost of more precautions and more"
" streamlined code."
msgstr ""

#: ../../source/tutorial/2-split.rst:703
msgid "Summary"
msgstr ""

#: ../../source/tutorial/2-split.rst:704
msgid ""
"Several analyses can be performed on one flow using an element *Split*. "
"It accepts a list of sequences as its first initialization argument."
msgstr ""

#: ../../source/tutorial/2-split.rst:707
msgid ""
"Since *Split* divides the flow into buffered slices, elements must be "
"prepared for that. In this part of the tutorial we introduced the "
"*FillCompute* and the *FillRequest* elements. The former yields the "
"results when its *compute* method is called. It is supposed that "
"*FillCompute* is run only once and that it is memory safe (that it "
"reduces data). If an element can consume much memory, it must be a "
"*FillRequest* element."
msgstr ""

#: ../../source/tutorial/2-split.rst:716
msgid ""
"If we add *Call* elements before and *Run* and *Call* elements after our "
"*FillCompute* or *FillRequest* elements, we can generalize them to "
"sequences *FillComputeSeq* and *FillRequestSeq*. They are created "
"implicitly during *Split* initialization."
msgstr ""

#: ../../source/tutorial/2-split.rst:722
msgid ""
"*Variables* connect functions with context. They have names and can have "
"LaTeX names, units and other parameters, which helps to create plots and "
"write output files. *Compose* corresponds to function composition, while "
"*Combine* creates multidimensional variables for multidimensional plots."
msgstr ""

#: ../../source/tutorial/2-split.rst:730
msgid ""
"If an element has methods with unusual names, adapters can be used to "
"relate them to the framework names. Adapters are also used to explicitly "
"cast one type of element to another or to implicitly convert an element "
"to an appropriate type during a sequence initialization."
msgstr ""

#: ../../source/tutorial/2-split.rst:736
msgid ""
"To be most useful, elements should be prepared to accept values "
"consisting of only data or data with context. To work safely with a "
"mutable context, a deep copy of that must be made in *compute* or "
"*request*. On the other hand, unnecessary deep copies (in *run*, *fill* "
"or *__call__*) may slightly decrease the performance. Lena allows "
"optimizations if they are needed."
msgstr ""

#: ../../source/tutorial/2-split.rst:746
msgid "Exercises"
msgstr ""

#: ../../source/tutorial/2-split.rst:747
msgid ""
"Extend the :ref:`Sum <sum>` example in this chapter so that it could "
"handle context. Check that it works."
msgstr ""

#: ../../source/tutorial/2-split.rst:750
msgid ""
"In the analysis example :ref:`main4.py <main4_py>` there are two "
"*MakeFilename* elements. Is it possible to use only one of them? How?"
msgstr ""

#: ../../source/tutorial/2-split.rst:754
msgid ""
"We developed the example :ref:`main2.py <main2_py>` and joined *lambda* "
"and *filename* into a *Variable*. We could also add a name to the "
"*Histogram*. Which design decision would be better?"
msgstr ""

#: ../../source/tutorial/2-split.rst:760
msgid "What are the consequences of calling *compute* even for an empty flow?"
msgstr ""

#: ../../source/tutorial/2-split.rst:762
msgid ""
"Alexander writes a diploma thesis involving some data analysis and wants "
"to choose a framework for that. He asks colleagues and professors, and "
"stops at three possible options. One library is easy to use and straight "
"to the point, and is sufficient for most diploma theses. Another library "
"is very rich and used by seasoned professionals, and its full power "
"surpasses even its documentation. The third framework doesn't provide a "
"plenty of mathematical functions, but promises structured and beautiful "
"code. Which one would you advise?"
msgstr ""

#: ../../source/tutorial/2-split.rst:774
msgid "Footnotes"
msgstr ""

#: ../../source/tutorial/2-split.rst:775
msgid ""
"PEP 544 -- Protocols: Structural subtyping (static duck typing): "
"https://www.python.org/dev/peps/pep-0544"
msgstr ""

#: ../../source/tutorial/2-split.rst:778
msgid ""
"One can use *tutorial/2_split/performance.py* to make a quick analysis. "
"To create 3 histograms (like in :ref:`main4.py <main4_py>` example above)"
" for one million generated events it took 82 seconds in Python 2 on a "
"laptop. The longest total time was spent for *copy.deepcopy* (20 "
"seconds). For Python 3, PyPy and PyPy 3 the total time was 71, 23 and 16 "
"seconds. These numbers are approximate (the second measurement for PyPy "
"gave 19 seconds). If we change *Variables* into *lambdas*, add "
"*MakeFilename* after *Histogram* and set *copy_buf=False* in *Split*, the"
" total time will be 18 seconds for Python 2 and 4 seconds for PyPy 3."
msgstr ""

#: ../../source/tutorial/2-split.rst:788
msgid ""
"This difference may be not important in practice: for example, the author"
" usually deals with data sets of several tens of thousands events, and a "
"large amount of time is spent to create 2-dimensional plots with "
"*pdflatex*."
msgstr ""

#: ../../source/tutorial/2-split.rst:794
msgid ""
"For framework elements this is obligatory, for user code this is "
"recommended."
msgstr ""

#~ msgid ""
#~ "*MakeFilename* accepts not only constant, "
#~ "but also format strings, which take "
#~ "arguments from context. In our example,"
#~ " *MakeFilename(\"{variable.name}\")* creates file "
#~ "name from *context.variable.name*."
#~ msgstr ""

